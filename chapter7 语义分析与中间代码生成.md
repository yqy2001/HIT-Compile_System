语法制导翻译那一章侧重于实现机制，中间代码生成这一章侧重于设计具体语法结构的SDT。

<img src="https://i.loli.net/2021/05/13/OtwJCTiZA4ycBGq.png" alt="image-20210513192135948" style="zoom:50%;" />

1、中间代码的形式

逆波兰表示：

优点：表达式的运算顺序就是运算符出现的顺序，不需要使用括号

| 中缀表示 | 前缀表示 | 后缀表示 |
| -------- | -------- | -------- |
| a+b      | +ab      | ab+      |
| a*(b+c)  | *a+bc    | abc+*    |

三地址码：

这种代码的每条指令最多包含三个地址：两个操作数地址和一个结果地址。
地址的形式可以是：名字（可能是一个指向符号表的指针）、常量、编译器生成的临时变量。

## 2、声明语句的翻译

声明语句：为程序中用到的变量或常量名指定类型。

语义分析的主要任务是：

* 收集标识符的类型等属性信息，可以知道**类型的宽度**
* 编译阶段，用类型的宽度为每一个名字分配一个**相对地址**

类型的作用：

* 类型检查：验证程序是否符合该语言关于类型的相关规则
* 辅助翻译：确定该名字的存储空间。

判定是不是LL1文法：看具有相同左部的产生式的可选集相不相交

LL1文法可以在自顶向下的分析过程中实现SDT

2.1 类型表达式

类型可以具有一定的层次结构

### 声明语句的翻译

由于翻译声明语句要确定变量的类型和偏移，故为每个变量设置综合属性width和type，type表示非终结符的类型，width是此类型的宽度。

设置的变量：
offset: 下一个可用的相对地址
t, w: 将类型和宽度信息从语法分析树的B结点传给C结点

例子见PPT

## 3、简单赋值语句的翻译

### 3.1 简单赋值语句

赋值语句的基本文法：
$$
S→id=E\\
E→E_1+E_2|E_1*E_2|-E_1|(E_1)|id
$$
赋值语句翻译的主要任务：生成对表达式求值的三地址码

为S和E都设定了综合属性code，用来表示其对应的三地址码，还为E设定了属性addr，表示表达式的值的存放地址。

三个函数：
lookup(name): 查询符号表，返回name对应的记录
gen(code): 构造出一个新的三地址指令code，并将他添加到已生成的指令序列之后。（增量翻译）
newtemp(): 生成一个新的临时变量t，返回t的地址

$E→id=E$：先在符号表中找到id，若没有则报错，生成id=E的三地址码

$E→id$：由于E直接推出id，故E的地址就是id的地址，用lookup(id.lexeme)在符号表中查找id的条目；若没找到，则报错，表明变量未定义先引用了；此条不需要生成三地址码，故E.code=''。

$E→E_1+E_2$：先为E生成一个新的临时变量，之后将赋值表达式添加到已生成的代码后面。

<img src="https://i.loli.net/2021/05/14/e3CxY7Bnuh24RUc.png" alt="image-20210514093533748" style="zoom:67%;" />

例子：见PPT，先构造LR分析表，然后根据分析表进行语法分析，在规约的时候执行相应的语义动作即可。

### 3.2 数组引用的翻译

翻译数组引用成三地址码要解决的主要问题：确定数组元素的存放地址（寻址）

$a[i_1][i_2]\dots[i_k]$的相对地址是$base+i_1*w_1+i_2*w_2+\dots+i_k*w_k$，其中$w_1$是$a[i_1]$的宽度，$w_2$是$a[i_1][i_2]$的宽度，以此类推，$w_k$就是$a[i_1][i_2]\dots[i_k]$的元素类型的宽度。

举例如下：假设有三元数组$type(a)=array(3,array(5,array(8,int)))$，一个整型变量占四个字节，则
$$
\begin{aligned}
addr(a[i_1][i_2][i_3]) &= base+i_1*w_1+i_2*w_2+i_3*w_3\\
 &= base+i_1*160+i_2*32+i_3*4
\end{aligned}
$$
L为生成数组的语法变量，设计一个type属性来表示数组元素的类型；offset属性计算数组引用的偏移量，用来累加；array属性表示数组在符号表的入口地址，即数组的基地址。

具体的语义动作，及一个语法分析的同时进行语义翻译的例子如下（数组的类型同上例）：

<img src="https://i.loli.net/2021/05/14/pQt1lAC7yg2cfT4.png" alt="image-20210514202817194" style="zoom: 50%;" />

### 3.3  控制流语句及其SDT

S表示可执行语句序列，可执行语句包括赋值语句、条件分支语句、循环语句。

基本文法：

<img src="https://i.loli.net/2021/05/15/r9sBFqVAjcmKvCD.png" alt="image-20210515090808263" style="zoom:50%;" />

设计如下的继承属性：

S.next: 存放紧跟在S代码之后的指令的标号
B.true: 一个地址，存放了B为真时控制流转向的指令标号
B.false: 存放B为假时控制流转向的指令标号

newlabel()表示生成一个用于存放标号的临时变量
label(L)将下一条三地址指令的标号赋给L

if-else条件分支语句：

<img src="https://i.loli.net/2021/05/15/AubMIUWKV3xiJkE.png" alt="image-20210515091505730" style="zoom:50%;" />

if-then：

<img src="https://i.loli.net/2021/05/15/gkZpHsYDRL8FSmM.png" alt="image-20210515091753823" style="zoom:50%;" />

while-do：

<img src="https://i.loli.net/2021/05/15/6BLqEWvKa4bPQdV.png" alt="image-20210515091811617" style="zoom:50%;" />

布尔表达式的SDT

控制流翻译的例子：

见PPT

先LR语法分析得到语法树，再进行自左向右的深度优先遍历，执行语义动作，生成三地址码，最后回填。

## 5、布尔表达式的回填

针对布尔表达式和控制流语句生成目标代码时，关键是确定跳转指令的目标标号。生成跳转指令时，目标标号还不能确定。

1、将存放标号的变量(地址)作为继承属性传递到标号生成的地方，但这样需要再进行一趟处理，将标号和具体地址绑定起来。

回填：
生成跳转指令时，暂时不指定其目标标号。这样的指令都被放入由跳转指令组成的**列表**中，同一列表中的所有跳转指令具有相同的目标标号。等到能确定正确的目标标号时，才去填充这些指令的目标标号。

这个列表是综合属性，以综合属性的形式进行传递。

B.truelist：指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是B为真时控制流转向的指令的标号
B.falselist: 同上，B假时跳转

函数：
makelist(i): 创建一个只包含i的列表，i是一条跳转指令的标号
merge(p1, p2): 合并p1和p2
backpatch(p, i): 回填，将i作为目标标号填入到p所指列表中的各属性中

<img src="chapter7 语义分析与中间代码生成.assets/image-20210523093335522.png" alt="image-20210523093335522" style="zoom:50%;" /><img src="chapter7 语义分析与中间代码生成.assets/image-20210523093417683.png" alt="image-20210523093417683" style="zoom:50%;" /><img src="chapter7 语义分析与中间代码生成.assets/image-20210523093448207.png" alt="image-20210523093448207" style="zoom:50%;" />

<img src="chapter7 语义分析与中间代码生成.assets/image-20210523093602168.png" alt="image-20210523093602168" style="zoom:50%;" />