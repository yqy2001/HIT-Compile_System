## 5.3 LR分析法（状态法）

LR分析法是**无回溯**的移进-规约分析方法；几乎所有描述程序设计语言的上下文无关文法，都能构造LR语法分析器；可以用LR方法分析的文法类是可以用LL法分析的文法类的**真超集**。

### 5.3.1 LR(k)分析法：

L：指从左到右扫描输入符号；
R：反向构造最右推导，即最左规约；
k：超前读入k个符号，以确定规约用的产生式(啥时候归约、怎样归约)。

思想：分析器根据当前状态，至多**向前查看k个输入符号，就可以确定是否找到了句柄**。若找到句柄，则可规约；若未找到句柄，则移进输入符号。移进和归约的过程中伴随着状态的转移。

**LR语法分析器的总体结构：**

结构如下图所示，工作流程为：分析程序从输入缓冲区中读入符号，根据分析表查询应该执行的操作，更新状态/符号栈。

所有LR分析器(LR(0)、SLR(1)、LR(1)、LALR(1))的主控程序、执行逻辑都是一样的，不同的语法分析器具有不同的**分析表**，分析表是LR分析法的核心。

<img src="https://i.loli.net/2021/04/07/uZcnlM7A4fFo6aj.png" alt="image-20210407085717240" style="zoom:50%;" />

**LR分析器的工作过程：**

1、初始化：$S_0\#\ \ \ \  a_1a_2\dots a_n\#$

2、一般情况下，假设分析器格局如下：$S_0S_1\dots S_m\#X_1\dots X_m\ \ \ \  a_ia_{i+1}\dots a_n\#$

* 如果$action[S_m, a_i] = sj(移入j)$，将格局变为：$S_0S_1\dots S_mj\#X_1\dots X_ma_i\ \ \ \  a_{i+1}\dots a_n\#$。即移入符号以及状态。

* 如果$action[S_m, a_i] = rj(归约j)$，将格局变为：$S_0S_1\dots S_{m-1}\#X_1\dots X_mA\ \ \ \  a_ia_{i+1}\dots a_n\#$。

  查goto表，如果$goto[s_{m-1},A]=K$，将格局变为：$S_0S_1\dots S_{m-1}K\#X_1\dots X_mA\ \ \ \  a_ia_{i+1}\dots a_n\#$

  即规约后，将和被归约的符号数量相等的状态出栈（例如将三个符号归约为A—>abc，就将三个状态出栈），并且使用出栈完的栈再执行一次查goto表，若goto成功则将那个状态压栈。

* 如果$action[S_m, a_i] = acc$，分析成功

* 如果$action[S_m, a_i] = err$，出现语法错误

举例如下，下面是分析表以及依据此分析表进行语法分析的详细过程：

<img src="https://i.loli.net/2021/05/01/8JxTAE5oOgYD6rn.png" alt="image-20210501101545753" style="zoom: 50%;" />

<img src="https://i.loli.net/2021/05/01/CltwLAiWO1U5JQk.png" alt="image-20210501101649021" style="zoom:50%;" />

### 5.3.2 LR(0)分析表的构造

思想：使用自动机维护一些状态，这些状态记录和追踪句柄形成的进程，句柄形成即归约。

LR(0)项目：右部某个位置标有圆点的产生式，称为LR(0)项目。若产生式的右部有n个符号，其对应的LR(0)项有n+1个。

例：对于产生式S➡bBB，其各项目为：

* 归约项目：S→bBB.
* 移进项目：S→.bBB
* 待约项目：S→b.BB、S→bB.B
* 接受项目：若S是开始符号，S→aBB.

自动机的状态是LR(0)项目的集合，使用LR(0)项目表示句柄的形成进度。

LR(0)自动机：
$$
M=(Q,\Sigma,\sigma,q_0,F)
$$
增广文法：

文法$G=(V, T, P, S)$的增广文法为$G'=(V \cup {S'}, T, P \cup \{S'→S\}, S'), S'\notin V$

* 初始项目：$S'→.S$
* 接受项目：$S'→S.$

下面要构造状态和状态转移函数（两个）：
将等价的项目组成一个项目集，成为项目集闭包，每个项目集闭包对应自动机的一个状态。
使用闭包计算等价的项目：${\rm CLOSURE(I)}=I\cup\{B→.\gamma|A→\alpha.B\beta\in I,B→\gamma\in P\}$，B是非终结符。也就是把点后面的非终结符都展开，一直迭代展开到不能展开为止。
状态转换函数为：${\rm GO(I)}={\rm CLOSURE}\{B→.\gamma|A→\alpha.B\beta\in I,B→\gamma\in P\}$。即不同状态间，使用的是点后面的符号进行转移。

由于将某个状态压入栈时，一定是移入了此状态的入边所对应的符号。又因为给定一个状态，所有入边上标记的符号是相同的，所以可以使用状态代表符号，即**状态和符号一一对应**。

例：

<img src="https://i.loli.net/2021/04/07/PbdGkL6DUYOgnh1.png" alt="image-20210407093950384" style="zoom: 50%;" />

LR(0)确定有穷自动机的形式化定义：$M=(C,V\cup T,GO,I_0,C)$，C是所有的项目集，叫做项目集规范族。

**LR分析表的构造算法：**

1、ACTION[I, a]，I为状态，a为终结符： 

* $A→\alpha.ab\in I$，且GO(I, a)=Ij，那么action[I, a]:=sj
* $A→\alpha.\in I$且此为第j个产生式，对任意的输入符号a，都进行归约
* $S^{'}→S.\in I$，那么action[I, #]:=acc

2、GOTO[I, X]，状态I，非终结符X

* $A→\alpha.X\beta\in I$，且GO(I, X)=Ij，则goto[I, X]:=j

3、其他情况无定义，报错

举例如下，根据自动机构造LR(0)分析表：

<img src="https://i.loli.net/2021/05/01/rTWQuPZ7w9q3ndN.png" alt="image-20210501192033879" style="zoom:50%;" />

若文法G对应的DFA的每个状态都满足这个条件：1、没有移进-归约冲突；2、没有归约-归约冲突，则此文法是LR0文法。

**规范句型活前缀：**

为什么可以用LR(0)自动机来做出移入-归约决定？暂时未明白

栈中内容一定是某个最右句型的前缀，称为规范句型活前缀。

根据当前状态I，给定输入符号a，若其在a上没有转移定义，则说明“栈中符号串+a”不再是活前缀，此时应该归约，若没有规约项目则出错。

LR(0)分析能力较差，很多上下文无关文法不能用LR(0)方法进行分析。

### 5.3.3 SLR(1)分析表

解决项目集中冲突的方法：归约时，向前搜索一个输入符号a，若$a\in {\rm FOLLOW(A)}$，则应用A→a.归约，否则移进

构造SLR(1)分析表，和LR(0)分析表的差别就在于，只有下一个输入符号$a\in {\rm FOLLOW(A)}$，才会用A→a.归约

### 5.3.4 LR(1)分析表的构造

对于产生式A→a的归约，在不同的使用位置，A会要求不同的后继符号。在特定位置，A的后继符集合时FOLLOW(A)的子集。

![image-20210501215719312](https://i.loli.net/2021/05/01/eCy2YHQbK5rGPVl.png)

1、后继项目继承原项目的展望符；
2、$[A→\alpha B.\beta,a]$扩展出$[B→.\gamma,b]$，$b\in FIRST(\beta a)$