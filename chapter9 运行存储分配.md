## 1、运行存储分配概述

编译器在工作过程中，需要为程序中的一些数据对象分配**运行时存储空间**。

* **静态存储分配**：对于在**编译时刻**就可以确定大小的对象，只通过看源代码文本就可以为他们分配存储空间，这叫静态存储分配。
* **动态存储分配**：若编译时不能确定数据对象的大小，就要采用动态存储分配策略（如动态数组）。即编译时仅产生各种必要的信息，而在**运行时刻**，再动态地分配空间。
    * 栈式存储分配
    * 堆式存储分配

<img src="chapter9 运行存储分配.assets/image-20210524203914024.png" alt="image-20210524203914024" style="zoom:50%;" />

#### 活动记录：

过程(函数)的每次执行称为一次活动。

过程的每次执行，都需要为他分配一块连续存储区，管理其一次执行所需要的信息，这块连续存储区称为**活动记录**。

在栈中存放活动记录，在过程调用的时候生成并进栈，在返回时出栈。

活动记录一般的组成：

<img src="chapter9 运行存储分配.assets/image-20210524204156155.png" alt="image-20210524204156155" style="zoom:50%;" />

## 2、静态存储分配：

为每个过程确定其活动记录在目标程序中的位置。

这样过程中每个名字的位置都确定了，其存储地址可以直接被编译到目标代码中。

过程每次执行，他的名字都绑定到同样的存储单元。

适合静态存储分配的语言必须满足以下条件：

* 数组的上下界必须是常数
* 不允许过程的递归调用
* 不允许动态建立数据实体

#### 顺序分配法

逐段给过程分配存储空间：

<img src="chapter9 运行存储分配.assets/image-20210525090247981.png" alt="image-20210525090247981" style="zoom:50%;" />

处理简单，但对内存的使用不合理

#### 层次分配法

对过程间的调用关系进行分析，对于无相互调用关系的并列过程，尽量让其局部数据共享存储空间

<img src="chapter9 运行存储分配.assets/image-20210525090420222.png" alt="image-20210525090420222" style="zoom:50%;" />

## 3、栈式存储分配

将运行时刻存储以栈的形式进行管理，称为栈式存储分配

当一个过程被调用时，其活动记录被压入栈；当过程结束时，此活动记录被弹出栈

好处：

* 允许活跃时段不重叠的过程调用之间共享空间
* 允许以如下方式为一个过程编译代码：非局部变量的相对地址总是固定的，和过程调用序列无关

#### 活动树

描述程序运行期间，控制进入和离开各个活动的情况的树。

每个结点对应一个活动，根结点是启动程序执行的main过程的活动。

某对应于过程p的结点，其子结点对应于p调用的各个过程，按照调用顺序，自左向右排列。一个子节点必须在其右兄弟结点的活动开始之前结束。

* 每个活跃的活动都有一个位于**控制栈**之中的活动记录
* 树根的活动记录位于栈底
* 程序控制所在的活动记录位于栈顶
* 栈中全部活动记录的序列，对应于活动树中到达当前控制所在活动节点的路径

例子如下：

<img src="chapter9 运行存储分配.assets/image-20210525093827030.png" alt="image-20210525093827030" style="zoom: 33%;" />

<img src="chapter9 运行存储分配.assets/image-20210525094408846.png" alt="image-20210525094408846" style="zoom:50%;" />

## 4、调用序列和返回序列

过程调用和过程返回都需要执行一些代码来管理活动记录栈，保存或恢复机器状态

* 调用序列：实现过程调用的代码段，为一个活动记录在栈中分配空间，并在此记录的字段中填写信息
* 返回序列：恢复机器状态，使得调用过程能在调用结束之后继续执行

调用序列和返回序列的代码通常被分割到调用者和被调用者中。

下面介绍调用序列和返回序列，假设P调用Q，P是调用者，Q是被调用者：

* 调用序列：
    * P计算实际参数的值，并将其填写到Q的**参数**字段
    * P将**返回地址**放到被调用者的**机器状态**字段，将原**top-sp值**放到被调用者的**控制链**中，让top-sp指向被调用者**局部数据开始**的位置
    * Q保存寄存器值和其他状态信息于**机器状态**字段。
    * Q初始化其局部数据并开始执行

* 返回序列：
    * Q将**返回值**放到与参数相邻的位置
    * 使用**机器状态**字段的信息，Q恢复top-sp和其他寄存器，然后跳转到返回地址
    * 尽管top-sp被恢复（减小），但调用者仍然知道返回值相对于当前top-sp值的位置。因此，调用者可以使用那个**返回值**

<img src="chapter9 运行存储分配.assets/image-20210525192451941.png" alt="image-20210525192451941" style="zoom:50%;" />

#### 变长数据的存储分配

编译时刻不能确定大小的对象被分配在堆区，但若他们是某过程的局部对象，也可以将他们分配在运行时刻栈中。

变长数组放在活动记录的后面：

<img src="chapter9 运行存储分配.assets/image-20210525192821420.png" alt="image-20210525192821420" style="zoom:50%;" />

## 5、非局部数据的访问

一个过程除了可以使用过程自身定义的局部数据，还可以使用过程外定义的**非局部数据**。

语言可以分为两种类型：

不支持过程嵌套声明的语言（C语言）：

* 简单，非局部数据就是**全局变量**，全局变量被分配在**静态区**，可以使用静态确定的地址来访问他们。
* 局部数据就是栈顶活动的局部变量。可以通过运行时刻栈的top_sp指针，访问他们。

#### 支持过程嵌套声明的语言（PASCAL语言）：

嵌套深度：

* 过程的嵌套深度：不内嵌在任何过程之中的过程，嵌套深度为1；若p嵌套在深度为i的过程中，则p为i+1
* 变量的嵌套深度：其所在过程的嵌套深度
* 举例：

<img src="chapter9 运行存储分配.assets/image-20210525194515148.png" alt="image-20210525194515148" style="zoom:50%;" />

### 访问链：

静态作用域规则：若过程b嵌套声明在过程a中，过程b就可以访问过程a中的对象。

在相互嵌套的过程的活动记录中建立访问链，使得内嵌过程可以访问外层过程中声明的对象。
若过程b在源代码中直接嵌套在过程a中，那么b的任何活动中的访问链都指向最近的过程a的活动。

<img src="chapter9 运行存储分配.assets/image-20210525195424243.png" alt="image-20210525195424243" style="zoom:50%;" />

#### 访问链的建立：

建立访问链的代码属于调用序列的一部分。

假设嵌套深度为$n_x$的过程x调用嵌套深度为$n_y$的过程y

$n_x<n_y$，外层调用内层，y只能是直接在x中定义的，则调用序列中，在y的访问链中放置一个指向x的指针

$n_x=n_y$，递归调用，被调用者直接复制调用者的访问链

$n_x>n_y$，内层调用外层，过程x必嵌套定义在某过程z中，z是y的直接外层过程，故从x开始，沿着访问链经过$n_x-n_y+1$步就可以找到离栈顶最近的z的活动记录，y的访问链指向此活动记录

## 6、符号表

为每个作用域（程序块）建立一个独立的符号表

表头有一个字段记录此过程的存储单元的数量